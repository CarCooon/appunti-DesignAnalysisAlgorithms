\chapter{Shortest Paths}
\label{cap:ShortestPaths}

Come abbiamo già visto, la ricerca in ampiezza (BFS) permette di trovare il cammino minimo in un grafo quando tutti gli archi sono considerati equivalenti. Tuttavia, in molte applicazioni reali questa condizione non è soddisfatta: per individuare il percorso più rapido tra due città o il tragitto più veloce per un pacchetto dati in rete, è necessario distinguere tra archi con caratteristiche diverse. Infatti, in questi contesti accade che alcune distanze tra le città saranno probabilmente molto più grandi di altre, e alcune connessioni in una rete di computer sono tipicamente molto più veloci di altre (ad esempio, alcune connessioni a bassa larghezza di banda contro connessioni ad alta velocità in fibra ottica). È quindi naturale considerare dei grafi pesatidove a ogni arco è associato un peso che ne rappresenta il costo o l'importanza.

\section{Weighted Graphs}
Un \textbf{weighted graph} (grafo pesato) è un grafo che ha un'etichetta numerica $w(e)$ associata a ciascun arco $e$, chiamata il peso (weight) dell'arco $e$. Per $e = (u,v)$, indichiamo il suo peso con la notazione $w(e) = w(u,v)$. 

\begin{figure}[!ht]
    \centering
    \includegraphics[width=0.9\textwidth]{immagini/ShortestPath/weighted_graph.png}
    \caption{Esempio di grafo pesato i cui vertici rappresentano i principali aeroporti degli Stati Uniti e i cui pesi degli archi rappresentano le distanze in miglia.}
    \label{fig:weighted_graph}
\end{figure}


\clearpage
\noindent
Sia $G$ un grafo pesato. La lunghezza (o peso) di un percorso $P$ è la somma dei pesi degli archi di $P$. Cioè, se $P = ((v_0,v_1), (v_1,v_2), \ldots , (v_{k-1},v_k))$, allora la lunghezza di $P$, indicata con $w(P)$, è definita come:

$$
w(P) = \sum_{i=1}^{k} w(v_{i-1}, v_i)
$$

\noindent
La \textbf{distanza} da un vertice $u$ a un vertice $v$ in $G$, indicata con $d(u,v)$, è la lunghezza di un percorso di lunghezza minima (chiamato anche \textbf{shortest path}) da $u$ a $v$, se tale percorso esiste.
Se non esiste alcun percorso da $u$ a $v$, allora utilizziamo la convenzione $d(u,v) = \infty$.

\paragraph{Proprietà di uno shortest path} 
\begin{enumerate}
    \item Un frammento di uno shortest path è anch'esso uno shortest path. Cioè, se $P$ è uno shortest path da $u$ a $v$ e $w$ è un vertice su $P$, allora il frammento di $P$ da $u$ a $w$ è uno shortest path da $u$ a $w$, e il frammento di $P$ da $w$ a $v$ è uno shortest path da $w$ a $v$.
    \item Gli shortest path da un vertice sorgente $s$ a tutti gli altri vertici costituiscono uno \textbf{shortest path spanning tree} (o shortest path tree) radicato in $s$.
\end{enumerate}

\begin{figure}[!ht]
    \centering
    \includegraphics[width=0.8\textwidth]{immagini/ShortestPath/shortest_path_tree.png}
    \caption{Esempio di uno shortest path tree radicato nel vertice PVD.}
    \label{fig:ex_shortest_path}
\end{figure}

\paragraph{Problemi legati agli shortest path} 
\begin{itemize}
    \item $(u, v)$-shortest path\\
    Dati due vertici $u$ e $v$, trovare lo shortest path tra $u$ e $v$.
    \item Single source shortest path\\
    Dato un vertice $s$, trovare lo shortest path tree radicato in $s$ (ovvero, trova lo shortest path da $s$ a tutti gli altri vertici).
    \item All-pairs shortest paths\\
    Trovare gli shortest path per tutte le coppie di vertici nel grafo.
\end{itemize}

\noindent
Si noti come dalla soluzione del problema single source shortest path sia possibile ottenere la soluzione del problema \emph{$(u, v)$-shortest path}, mentre dalla soluzione del problema \emph{all-pairs shortest paths} sia possibile ottenere la soluzione di entrambi gli altri problemi. Tuttavia, è anche possibile risolvere il problema \emph{all-pairs shortest paths} eseguendo l'algoritmo per il \emph{single source shortest path} per ogni vertice del grafo.

\clearpage
\section{Algoritmo di Dijkstra}
Si vuole sviluppare un \textbf{algoritmo Greedy} per la risoluzione del problema \emph{single source shortest path}. L'idea principale nell'applicare il \emph{metodo Greedy} al problema degli shortest path da una singola sorgente è quella di eseguire una "ricerca in ampiezza pesata" a partire dal vertice sorgente $s$. In particolare, possiamo utilizzare il \emph{metodo Greedy} per sviluppare un algoritmo che cresce iterativamente una "nuvola" di vertici a partire da $s$, con i vertici che entrano nella nuvola in ordine di distanza da $s$. Quindi, in ogni iterazione, il prossimo vertice scelto è il vertice al di fuori della nuvola che è più vicino a $s$. L'algoritmo termina quando non ci sono più vertici al di fuori della nuvola (o quando quelli al di fuori della nuvola non sono connessi a quelli all'interno della nuvola, e quindi hanno distanza infinita), a quel punto abbiamo uno shortest path da $s$ a ogni vertice di $G$ raggiungibile da $s$. Questo approccio è un esempio semplice, ma comunque potente, del \emph{metodo Greedy}. 

L'applicazione del \emph{metodo Greedy} al problema degli shortest path da una singola sorgente porta a un algoritmo noto come \textbf{algoritmo di Dijkstra}.


\subsection*{Edge Relaxation - Greedy Choice}
Definiamo un'etichetta $D(v)$ per ogni vertice $v$ in $V$, che utilizziamo per approssimare la distanza da $s$ a $v$ in $G$. Il significato di queste etichette è che $D(v)$ memorizzerà sempre la lunghezza del miglior percorso che abbiamo trovato finora da $s$ a $v$. Difatti, possiamo pensare a $D(v)$ come un lmite superiore della distanza minima reale $d(s,v)$. Inoltre, definiamo un insieme $C$, che rappresenta l'insieme di vertici nella "nuvola", ovvero quei vertici per i quali abbiamo già calcolato la distanza minima da $s$.

Inizialmente, definiamo $D(s) = 0$ e $D(v) = \infty$ per ogni $v \neq s$, e l'insieme $C$ come l'insieme vuoto. Ad ogni iterazione dell'algoritmo, selezioniamo un vertice $u$ non in $C$ con l'etichetta $D(u)$ più piccola, e lo aggiungiamo a $C$ (Generalmente, utilizzeremo una coda di priorità per selezionare tra i vertici al di fuori della nuvola, per via dell'efficienza del metodo \texttt{remove\_min()}). 

Nella prima iterazione, ovviamente, aggiungeremo $s$ a $C$. Una volta che un nuovo vertice $u$ viene aggiunto a $C$, aggiorniamo l'etichetta $D(v)$ di ogni vertice $v$ adiacente a $u$ e che è al di fuori di $C$, per riflettere il fatto che potrebbe esserci un nuovo e migliore modo per raggiungere $v$ passando per $u$. Questa operazione di aggiornamento è nota come \emph{rilassamento degli archi} (\textbf{edge relaxation}), poiché prende una vecchia stima e verifica se può essere migliorata per avvicinarsi al suo valore reale. L'operazione specifica di rilassamento degli archi è la seguente:

\vspace{1\baselineskip}
$\quad \quad \quad \textbf{Edge Relaxation:}$
$$
\begin{aligned}
&\textbf{if } D(u) + w(u,v) < D(v) \textbf{ then} \\
&\quad D(v) = D(u) + w(u,v)
\end{aligned}
$$

\clearpage




